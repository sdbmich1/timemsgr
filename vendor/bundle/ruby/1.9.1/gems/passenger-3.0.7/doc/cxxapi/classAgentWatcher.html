<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Passenger: AgentWatcher Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.2 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>AgentWatcher Class Reference</h1><!-- doxytag: class="AgentWatcher" -->
<p>Abstract base class for watching agent processes.  
<a href="#_details">More...</a></p>

<p>Inherited by HelperAgentWatcher, and LoggingAgentWatcher.</p>

<p><a href="classAgentWatcher-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAgentWatcher.html#aa9f83ed13b06ef80d0417f9c313cf61e">sendStartupInfo</a> (<a class="el" href="classPassenger_1_1MessageChannel.html">MessageChannel</a> &amp;channel)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Send the started agent process's startup information over the given channel, to the starter process.  <a href="#aa9f83ed13b06ef80d0417f9c313cf61e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAgentWatcher.html#a982a388ed5c485ab9615c5bc0abbc71e">name</a> () const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the name of the agent that this class is watching.  <a href="#a982a388ed5c485ab9615c5bc0abbc71e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual pid_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAgentWatcher.html#adaf1c0a7104aea662d90f639066b8247">start</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Starts the agent process.  <a href="#adaf1c0a7104aea662d90f639066b8247"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAgentWatcher.html#a3da11d23ed3b1210a24844856b7f3159">startWatching</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start watching the agent process.  <a href="#a3da11d23ed3b1210a24844856b7f3159"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAgentWatcher.html#ae65876d2cc680b739dfee02378233340">forceShutdown</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Force the agent process to shut down.  <a href="#ae65876d2cc680b739dfee02378233340"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAgentWatcher.html#ab99d4346d7b69d86db1b14206e7caadb">getErrorMessage</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If the watcher thread has encountered an error, then the error message will be stored here.  <a href="#ab99d4346d7b69d86db1b14206e7caadb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a80ef9eaf1a84d994e7ba5f1507616fde"></a><!-- doxytag: member="AgentWatcher::getErrorBacktrace" ref="a80ef9eaf1a84d994e7ba5f1507616fde" args="() const " -->
string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAgentWatcher.html#a80ef9eaf1a84d994e7ba5f1507616fde">getErrorBacktrace</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The error backtrace, if applicable. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classPassenger_1_1FileDescriptor.html">FileDescriptor</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAgentWatcher.html#ac0749ab103ed5d1adc81b53a7ddc93d8">getFeedbackFd</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the agent process feedback fd, or -1 if the agent process hasn't been started yet.  <a href="#ac0749ab103ed5d1adc81b53a7ddc93d8"></a><br/></td></tr>
<tr><td colspan="2"><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAgentWatcher.html#a77279925d786a774bdf097468c36af96">getExeFilename</a> () const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the filename of the agent process's executable.  <a href="#a77279925d786a774bdf097468c36af96"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAgentWatcher.html#ac6325cb940f9c25ef2f44aca00c30755">execProgram</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method is to exec() the agent with the right arguments.  <a href="#ac6325cb940f9c25ef2f44aca00c30755"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAgentWatcher.html#a45bc0e41253a0c287e14f708f7dba1e6">sendStartupArguments</a> (pid_t <a class="el" href="classAgentWatcher.html#a76de201bbc7111c01c31668211494fa8">pid</a>, <a class="el" href="classPassenger_1_1FileDescriptor.html">FileDescriptor</a> &amp;fd)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method is to send startup arguments to the agent process through the given file descriptor, which is the agent process's feedback fd.  <a href="#a45bc0e41253a0c287e14f708f7dba1e6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAgentWatcher.html#a4c1c454374c8916788fee166beacfb05">processStartupInfo</a> (pid_t <a class="el" href="classAgentWatcher.html#a76de201bbc7111c01c31668211494fa8">pid</a>, <a class="el" href="classPassenger_1_1FileDescriptor.html">FileDescriptor</a> &amp;fd, const vector&lt; string &gt; &amp;args)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method is to process the startup info that the agent process has sent back.  <a href="#a4c1c454374c8916788fee166beacfb05"></a><br/></td></tr>
<tr><td colspan="2"><h2>Static Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAgentWatcher.html#a9c50694046e32a8b900420cb473e9e16">killAndWait</a> (pid_t <a class="el" href="classAgentWatcher.html#a76de201bbc7111c01c31668211494fa8">pid</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Kill a process with SIGKILL, and attempt to kill its children too.  <a href="#a9c50694046e32a8b900420cb473e9e16"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a231e843bd6d916650f7e7a641c5b4ca4"></a><!-- doxytag: member="AgentWatcher::timedWaitPid" ref="a231e843bd6d916650f7e7a641c5b4ca4" args="(pid_t pid, int *status, unsigned long long timeout)" -->
static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAgentWatcher.html#a231e843bd6d916650f7e7a641c5b4ca4">timedWaitPid</a> (pid_t <a class="el" href="classAgentWatcher.html#a76de201bbc7111c01c31668211494fa8">pid</a>, int *status, unsigned long long timeout)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Behaves like <code>waitpid(pid, status, WNOHANG)</code>, but waits at most <em>timeout</em> miliseconds for the process to exit. <br/></td></tr>
<tr><td colspan="2"><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">pid_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAgentWatcher.html#a76de201bbc7111c01c31668211494fa8">pid</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">PID of the process we're watching.  <a href="#a76de201bbc7111c01c31668211494fa8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAgentWatcher.html#ac4fa4122858073a1e3e1d96ce2ade6f2">threadExceptionMessage</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If the watcher thread threw an uncaught exception then its information will be stored here so that the main thread can check whether a watcher encountered an error.  <a href="#ac4fa4122858073a1e3e1d96ce2ade6f2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPassenger_1_1FileDescriptor.html">FileDescriptor</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAgentWatcher.html#aa3eba8fe19117a84764f5f653a03612d">feedbackFd</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The agent process's feedback fd.  <a href="#aa3eba8fe19117a84764f5f653a03612d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a22ad2ee317c4e254833ab07f377ed7fd"></a><!-- doxytag: member="AgentWatcher::lock" ref="a22ad2ee317c4e254833ab07f377ed7fd" args="" -->
boost::mutex&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAgentWatcher.html#a22ad2ee317c4e254833ab07f377ed7fd">lock</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Lock for protecting the exchange of data between the main thread and the watcher thread. <br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Abstract base class for watching agent processes. </p>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ac6325cb940f9c25ef2f44aca00c30755"></a><!-- doxytag: member="AgentWatcher::execProgram" ref="ac6325cb940f9c25ef2f44aca00c30755" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void AgentWatcher::execProgram </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This method is to exec() the agent with the right arguments. </p>
<p>It is called from within a forked child process, so don't do any dynamic memory allocations in here. It must also not throw any exceptions. It must also preserve the value of errno after exec() is called. </p>

</div>
</div>
<a class="anchor" id="ae65876d2cc680b739dfee02378233340"></a><!-- doxytag: member="AgentWatcher::forceShutdown" ref="ae65876d2cc680b739dfee02378233340" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool AgentWatcher::forceShutdown </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Force the agent process to shut down. </p>
<p>Returns true if it was shut down, or false if it wasn't started. </p>

</div>
</div>
<a class="anchor" id="ab99d4346d7b69d86db1b14206e7caadb"></a><!-- doxytag: member="AgentWatcher::getErrorMessage" ref="ab99d4346d7b69d86db1b14206e7caadb" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string AgentWatcher::getErrorMessage </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If the watcher thread has encountered an error, then the error message will be stored here. </p>
<p>If the error message is empty then it means everything is still OK. </p>

</div>
</div>
<a class="anchor" id="a77279925d786a774bdf097468c36af96"></a><!-- doxytag: member="AgentWatcher::getExeFilename" ref="a77279925d786a774bdf097468c36af96" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual string AgentWatcher::getExeFilename </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [protected, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the filename of the agent process's executable. </p>
<p>This method may be called in a forked child process and may therefore not allocate memory. </p>

</div>
</div>
<a class="anchor" id="ac0749ab103ed5d1adc81b53a7ddc93d8"></a><!-- doxytag: member="AgentWatcher::getFeedbackFd" ref="ac0749ab103ed5d1adc81b53a7ddc93d8" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classPassenger_1_1FileDescriptor.html">FileDescriptor</a> AgentWatcher::getFeedbackFd </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the agent process feedback fd, or -1 if the agent process hasn't been started yet. </p>
<p>Can be used to check whether this agent process has exited without using waitpid(). </p>

</div>
</div>
<a class="anchor" id="a9c50694046e32a8b900420cb473e9e16"></a><!-- doxytag: member="AgentWatcher::killAndWait" ref="a9c50694046e32a8b900420cb473e9e16" args="(pid_t pid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void AgentWatcher::killAndWait </td>
          <td>(</td>
          <td class="paramtype">pid_t&nbsp;</td>
          <td class="paramname"> <em>pid</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Kill a process with SIGKILL, and attempt to kill its children too. </p>
<p>Then wait until it has quit. </p>

</div>
</div>
<a class="anchor" id="a982a388ed5c485ab9615c5bc0abbc71e"></a><!-- doxytag: member="AgentWatcher::name" ref="a982a388ed5c485ab9615c5bc0abbc71e" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char* AgentWatcher::name </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the name of the agent that this class is watching. </p>

</div>
</div>
<a class="anchor" id="a4c1c454374c8916788fee166beacfb05"></a><!-- doxytag: member="AgentWatcher::processStartupInfo" ref="a4c1c454374c8916788fee166beacfb05" args="(pid_t pid, FileDescriptor &amp;fd, const vector&lt; string &gt; &amp;args)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool AgentWatcher::processStartupInfo </td>
          <td>(</td>
          <td class="paramtype">pid_t&nbsp;</td>
          <td class="paramname"> <em>pid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPassenger_1_1FileDescriptor.html">FileDescriptor</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; string &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>args</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This method is to process the startup info that the agent process has sent back. </p>
<p>May throw arbitrary exceptions. </p>

</div>
</div>
<a class="anchor" id="a45bc0e41253a0c287e14f708f7dba1e6"></a><!-- doxytag: member="AgentWatcher::sendStartupArguments" ref="a45bc0e41253a0c287e14f708f7dba1e6" args="(pid_t pid, FileDescriptor &amp;fd)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void AgentWatcher::sendStartupArguments </td>
          <td>(</td>
          <td class="paramtype">pid_t&nbsp;</td>
          <td class="paramname"> <em>pid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPassenger_1_1FileDescriptor.html">FileDescriptor</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>fd</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This method is to send startup arguments to the agent process through the given file descriptor, which is the agent process's feedback fd. </p>
<p>May throw arbitrary exceptions. </p>

</div>
</div>
<a class="anchor" id="aa9f83ed13b06ef80d0417f9c313cf61e"></a><!-- doxytag: member="AgentWatcher::sendStartupInfo" ref="aa9f83ed13b06ef80d0417f9c313cf61e" args="(MessageChannel &amp;channel)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void AgentWatcher::sendStartupInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPassenger_1_1MessageChannel.html">MessageChannel</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>channel</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Send the started agent process's startup information over the given channel, to the starter process. </p>
<p>May throw arbitrary exceptions.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><a class="el" href="classAgentWatcher.html#adaf1c0a7104aea662d90f639066b8247" title="Starts the agent process.">start()</a> has been called and succeeded. </dd></dl>

</div>
</div>
<a class="anchor" id="adaf1c0a7104aea662d90f639066b8247"></a><!-- doxytag: member="AgentWatcher::start" ref="adaf1c0a7104aea662d90f639066b8247" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual pid_t AgentWatcher::start </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Starts the agent process. </p>
<p>May throw arbitrary exceptions. </p>

</div>
</div>
<a class="anchor" id="a3da11d23ed3b1210a24844856b7f3159"></a><!-- doxytag: member="AgentWatcher::startWatching" ref="a3da11d23ed3b1210a24844856b7f3159" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void AgentWatcher::startWatching </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Start watching the agent process. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><a class="el" href="classAgentWatcher.html#adaf1c0a7104aea662d90f639066b8247" title="Starts the agent process.">start()</a> has been called and succeeded. </dd>
<dd>
This watcher isn't already watching. </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>RuntimeException</em>&nbsp;</td><td>If a precondition failed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>thread_interrupted</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>thread_resource_error</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="aa3eba8fe19117a84764f5f653a03612d"></a><!-- doxytag: member="AgentWatcher::feedbackFd" ref="aa3eba8fe19117a84764f5f653a03612d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPassenger_1_1FileDescriptor.html">FileDescriptor</a> <a class="el" href="classAgentWatcher.html#aa3eba8fe19117a84764f5f653a03612d">AgentWatcher::feedbackFd</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The agent process's feedback fd. </p>

</div>
</div>
<a class="anchor" id="a76de201bbc7111c01c31668211494fa8"></a><!-- doxytag: member="AgentWatcher::pid" ref="a76de201bbc7111c01c31668211494fa8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pid_t <a class="el" href="classAgentWatcher.html#a76de201bbc7111c01c31668211494fa8">AgentWatcher::pid</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>PID of the process we're watching. </p>
<p>0 if no process is started at this time. </p>

</div>
</div>
<a class="anchor" id="ac4fa4122858073a1e3e1d96ce2ade6f2"></a><!-- doxytag: member="AgentWatcher::threadExceptionMessage" ref="ac4fa4122858073a1e3e1d96ce2ade6f2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string <a class="el" href="classAgentWatcher.html#ac4fa4122858073a1e3e1d96ce2ade6f2">AgentWatcher::threadExceptionMessage</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If the watcher thread threw an uncaught exception then its information will be stored here so that the main thread can check whether a watcher encountered an error. </p>
<p>These are empty strings if everything is OK. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>Watchdog.cpp</li>
</ul>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
</body>
</html>
