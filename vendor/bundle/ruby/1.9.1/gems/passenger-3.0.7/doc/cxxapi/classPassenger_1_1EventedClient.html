<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Passenger: Passenger::EventedClient Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.2 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespacePassenger.html">Passenger</a>::<a class="el" href="classPassenger_1_1EventedClient.html">EventedClient</a>
  </div>
</div>
<div class="contents">
<h1>Passenger::EventedClient Class Reference</h1><!-- doxytag: class="Passenger::EventedClient" -->
<p>A utility class for making I/O handling in non-blocking libev evented servers much easier.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="EventedClient_8h_source.html">EventedClient.h</a>&gt;</code></p>

<p>Inherited by Passenger::EventedMessageClient.</p>

<p><a href="classPassenger_1_1EventedClient-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="classPassenger_1_1EventedClient.html#a931edf284fed32f74ebf9dc35d993f17a627c2190c3a4dc848dc1a332ef9f5105">DISCONNECT_FULL</a>, 
<a class="el" href="classPassenger_1_1EventedClient.html#a931edf284fed32f74ebf9dc35d993f17a232760bee5b535fd40e609ff8c088693">DISCONNECT_WRITE</a>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Controls what to do when a write error is encountered. </p>
 <a href="classPassenger_1_1EventedClient.html#a931edf284fed32f74ebf9dc35d993f17">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1EventedClient.html#ac3c45bfa7ac30b6d59ef08dc296f3c4e">EventedClient</a> (struct ev_loop *loop, const <a class="el" href="classPassenger_1_1FileDescriptor.html">FileDescriptor</a> &amp;_fd)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a new <a class="el" href="classPassenger_1_1EventedClient.html" title="A utility class for making I/O handling in non-blocking libev evented servers much...">EventedClient</a> with the given libev loop and file descriptor.  <a href="#ac3c45bfa7ac30b6d59ef08dc296f3c4e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aec0aee41bd623d7a3f3cd8ae201ba717"></a><!-- doxytag: member="Passenger::EventedClient::ref" ref="aec0aee41bd623d7a3f3cd8ae201ba717" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1EventedClient.html#aec0aee41bd623d7a3f3cd8ae201ba717">ref</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Increase reference count. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1EventedClient.html#a1e480f15dfd339ff781f8daedc5b8190">unref</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Decrease reference count.  <a href="#a1e480f15dfd339ff781f8daedc5b8190"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1EventedClient.html#a50436eb8ec0cc38b5a7278962e98a22c">ioAllowed</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns whether it is allowed to perform some kind of I/O with this client, either reading or writing.  <a href="#a50436eb8ec0cc38b5a7278962e98a22c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1EventedClient.html#aca719fb03ade09839827a16caa0e6e30">writeAllowed</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns whether it is allowed to write data to the client.  <a href="#aca719fb03ade09839827a16caa0e6e30"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1EventedClient.html#a129f6d6a6123c9af1999eca4ae04a75a">readWatcherActive</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Used by unit tests.  <a href="#a129f6d6a6123c9af1999eca4ae04a75a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1EventedClient.html#a0a032e54979b074641ffda807648a6e2">pendingWrites</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the number of bytes that are scheduled to be sent to the client at a later time.  <a href="#a0a032e54979b074641ffda807648a6e2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1EventedClient.html#a56ac52f1a4e77c49f72202d16e588f2f">notifyReads</a> (bool enable)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets whether you're interested in read events.  <a href="#a56ac52f1a4e77c49f72202d16e588f2f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1EventedClient.html#ac1eb48c0d5382a97facbf9af40924849">setOutboxLimit</a> (unsigned int size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets a limit on the client outbox.  <a href="#ac1eb48c0d5382a97facbf9af40924849"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1EventedClient.html#aa07723456786b9f18b973bd88ff51e27">write</a> (const <a class="el" href="classPassenger_1_1StaticString.html">StaticString</a> data[], unsigned int count)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sends data to this client.  <a href="#aa07723456786b9f18b973bd88ff51e27"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1EventedClient.html#a9161e34ddc473c00fe4df8fdb1d1baef">closeWrite</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Close only the writer side of the client connection.  <a href="#a9161e34ddc473c00fe4df8fdb1d1baef"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1EventedClient.html#a5b1a3011165ea9a47f6fe668a5010a20">disconnect</a> (bool force=false)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Disconnects the client.  <a href="#a5b1a3011165ea9a47f6fe668a5010a20"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPassenger_1_1FileDescriptor.html">FileDescriptor</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1EventedClient.html#a408b593d118c3483bcef8118a7edba0f">detach</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Detaches the client file descriptor so that this <a class="el" href="classPassenger_1_1EventedClient.html" title="A utility class for making I/O handling in non-blocking libev evented servers much...">EventedClient</a> no longer has any control over it.  <a href="#a408b593d118c3483bcef8118a7edba0f"></a><br/></td></tr>
<tr><td colspan="2"><h2>Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPassenger_1_1FileDescriptor.html">FileDescriptor</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1EventedClient.html#a4473719c16cae760e1811b7ccb1dc491">fd</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The client's file descriptor.  <a href="#a4473719c16cae760e1811b7ccb1dc491"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum <br class="typebreak"/>
Passenger::EventedClient:: { ... } &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1EventedClient.html#afc0934988a978a25538b7d8f2566c90a">writeErrorAction</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Controls what to do when a write error is encountered.  <a href="#afc0934988a978a25538b7d8f2566c90a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Callback&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1EventedClient.html#a155988f311fba920bef3031f3d9b6f6a">onReadable</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called when the file descriptor becomes readable and read notifications are enabled (see <code>notifyRead()</code>).  <a href="#a155988f311fba920bef3031f3d9b6f6a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Callback&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1EventedClient.html#a211210ecd85eb2da47d200215132bb2d">onDisconnect</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called when the client is disconnected.  <a href="#a211210ecd85eb2da47d200215132bb2d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a742805d40508b0af89eb2ed2c1e50060"></a><!-- doxytag: member="Passenger::EventedClient::onDetach" ref="a742805d40508b0af89eb2ed2c1e50060" args="" -->
Callback&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1EventedClient.html#a742805d40508b0af89eb2ed2c1e50060">onDetach</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called when <code><a class="el" href="classPassenger_1_1EventedClient.html#a408b593d118c3483bcef8118a7edba0f" title="Detaches the client file descriptor so that this EventedClient no longer has any...">detach()</a></code> is called for the first time. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Callback&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1EventedClient.html#a22e93ce2be05a4f47dbeba95d79a79b9">onPendingDataFlushed</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called after all pending outgoing data have been written out.  <a href="#a22e93ce2be05a4f47dbeba95d79a79b9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9522b2c5a42d75a93ed865e74510818f"></a><!-- doxytag: member="Passenger::EventedClient::onSystemError" ref="a9522b2c5a42d75a93ed865e74510818f" args="" -->
SystemErrorCallback&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1EventedClient.html#a9522b2c5a42d75a93ed865e74510818f">onSystemError</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">System call errors are reported with this callback. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1EventedClient.html#a793c843b7ba01cc1bb2c568c6539b9e0">userData</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classPassenger_1_1EventedClient.html" title="A utility class for making I/O handling in non-blocking libev evented servers much...">EventedClient</a> doesn't do anything with this.  <a href="#a793c843b7ba01cc1bb2c568c6539b9e0"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>A utility class for making I/O handling in non-blocking libev evented servers much easier. </p>
<ul>
<li>An <a class="el" href="classPassenger_1_1EventedClient.html" title="A utility class for making I/O handling in non-blocking libev evented servers much...">EventedClient</a> is associated with a reference counted file descriptor.</li>
<li>It contains connection state information (i.e. whether the connection is established or closed). Callbacks are provided for watching connection state changes (e.g. <code>onDisconnect</code>).</li>
<li>It provides reference counting features for simpler memory management (<code><a class="el" href="classPassenger_1_1EventedClient.html#aec0aee41bd623d7a3f3cd8ae201ba717" title="Increase reference count.">ref()</a></code> and <code><a class="el" href="classPassenger_1_1EventedClient.html#a1e480f15dfd339ff781f8daedc5b8190" title="Decrease reference count.">unref()</a></code>).</li>
<li>It installs input and output readiness watchers that are unregistered when the <a class="el" href="classPassenger_1_1EventedClient.html" title="A utility class for making I/O handling in non-blocking libev evented servers much...">EventedClient</a> is destroyed. One can hook into input readiness watcher with the <code>onReadable</code> callback.</li>
<li>Makes zero-copy writes easy. The <code>write()</code> method accepts an array of buffers. Whenever possible, all of these buffers are written out in the given order, using a single system call, without copying them into a single temporary buffer.</li>
<li>Makes non-blocking writes easy. Normally a write() system call on a non-blocking socket can fail with EAGAIN if the socket send buffer is full. <a class="el" href="classPassenger_1_1EventedClient.html" title="A utility class for making I/O handling in non-blocking libev evented servers much...">EventedClient</a> schedules the data to be sent later when the socket is writable again. It automatically integrates into the main loop in order to do this. This allows one to have write operations occur concurrently with read operations. In case too many scheduled writes are being piled up, <a class="el" href="classPassenger_1_1EventedClient.html" title="A utility class for making I/O handling in non-blocking libev evented servers much...">EventedClient</a> is smart enough to temporarily disable read notifications and wait until everything is written out before enabling read notifications again. The definition of "too many" is customizable (<code><a class="el" href="classPassenger_1_1EventedClient.html#ac1eb48c0d5382a97facbf9af40924849" title="Sets a limit on the client outbox.">setOutboxLimit()</a></code>).</li>
<li>EventedClient's <code>disconnect</code> method respects pending writes. It will disconnect after all pending outgoing data have been written out.</li>
</ul>
<h2>Basic usage</h2>
<p>Construct an <a class="el" href="classPassenger_1_1EventedClient.html" title="A utility class for making I/O handling in non-blocking libev evented servers much...">EventedClient</a> with a libev loop and a file descriptor:</p>
<div class="fragment"><pre class="fragment"> <a class="code" href="classPassenger_1_1EventedClient.html#ac3c45bfa7ac30b6d59ef08dc296f3c4e" title="Creates a new EventedClient with the given libev loop and file descriptor.">EventedClient</a> *client = <span class="keyword">new</span> <a class="code" href="classPassenger_1_1EventedClient.html#ac3c45bfa7ac30b6d59ef08dc296f3c4e" title="Creates a new EventedClient with the given libev loop and file descriptor.">EventedClient</a>(loop, <a class="code" href="classPassenger_1_1EventedClient.html#a4473719c16cae760e1811b7ccb1dc491" title="The client&amp;#39;s file descriptor.">fd</a>);
</pre></div><p>You are probably interested in read readiness notifications on <code>fd</code>. However these notifications are disabled by default. You need to set the <code>onReadable</code> callback (which is called every time the fd is readable) and enable read notifications.</p>
<div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> <a class="code" href="classPassenger_1_1EventedClient.html#a155988f311fba920bef3031f3d9b6f6a" title="Called when the file descriptor becomes readable and read notifications are enabled...">onReadable</a>(<a class="code" href="classPassenger_1_1EventedClient.html#ac3c45bfa7ac30b6d59ef08dc296f3c4e" title="Creates a new EventedClient with the given libev loop and file descriptor.">EventedClient</a> *client) {
     <span class="comment">// do whatever you want</span>
 }
 
 ...
 client-&gt;onReadable = <a class="code" href="classPassenger_1_1EventedClient.html#a155988f311fba920bef3031f3d9b6f6a" title="Called when the file descriptor becomes readable and read notifications are enabled...">onReadable</a>;
 client-&gt;notifyReads(<span class="keyword">true</span>);
</pre></div><h2>Error handling</h2>
<p><a class="el" href="classPassenger_1_1EventedClient.html" title="A utility class for making I/O handling in non-blocking libev evented servers much...">EventedClient</a> never raises exceptions, except when your callbacks do. It reports errors with the <code>onSystemError</code> callback. That said, <a class="el" href="classPassenger_1_1EventedClient.html" title="A utility class for making I/O handling in non-blocking libev evented servers much...">EventedClient</a> is exception-aware and will ensure that its internal state stays consistent even when your callbacks throw exceptions. </p>
<hr/><h2>Member Enumeration Documentation</h2>
<a class="anchor" id="a931edf284fed32f74ebf9dc35d993f17"></a><!-- doxytag: member="Passenger::EventedClient::@1" ref="a931edf284fed32f74ebf9dc35d993f17" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Controls what to do when a write error is encountered. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a931edf284fed32f74ebf9dc35d993f17a627c2190c3a4dc848dc1a332ef9f5105"></a><!-- doxytag: member="DISCONNECT_FULL" ref="a931edf284fed32f74ebf9dc35d993f17a627c2190c3a4dc848dc1a332ef9f5105" args="" -->DISCONNECT_FULL</em>&nbsp;</td><td>
<p>Forcefully disconnect the client. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a931edf284fed32f74ebf9dc35d993f17a232760bee5b535fd40e609ff8c088693"></a><!-- doxytag: member="DISCONNECT_WRITE" ref="a931edf284fed32f74ebf9dc35d993f17a232760bee5b535fd40e609ff8c088693" args="" -->DISCONNECT_WRITE</em>&nbsp;</td><td>
<p>Close the writer side of the connection, but continue allowing reading. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ac3c45bfa7ac30b6d59ef08dc296f3c4e"></a><!-- doxytag: member="Passenger::EventedClient::EventedClient" ref="ac3c45bfa7ac30b6d59ef08dc296f3c4e" args="(struct ev_loop *loop, const FileDescriptor &amp;_fd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Passenger::EventedClient::EventedClient </td>
          <td>(</td>
          <td class="paramtype">struct ev_loop *&nbsp;</td>
          <td class="paramname"> <em>loop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPassenger_1_1FileDescriptor.html">FileDescriptor</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>_fd</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a new <a class="el" href="classPassenger_1_1EventedClient.html" title="A utility class for making I/O handling in non-blocking libev evented servers much...">EventedClient</a> with the given libev loop and file descriptor. </p>
<p>The initial reference count is 1. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a9161e34ddc473c00fe4df8fdb1d1baef"></a><!-- doxytag: member="Passenger::EventedClient::closeWrite" ref="a9161e34ddc473c00fe4df8fdb1d1baef" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Passenger::EventedClient::closeWrite </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Close only the writer side of the client connection. </p>
<p>After calling this method, subsequent write() calls won't do anything anymore. Any pending outgoing data will be sent out whenever the opportunity arises.</p>
<p>This function does nothing if the client is being disconnected, already disconnected or if only the writer side is closed. </p>

</div>
</div>
<a class="anchor" id="a408b593d118c3483bcef8118a7edba0f"></a><!-- doxytag: member="Passenger::EventedClient::detach" ref="a408b593d118c3483bcef8118a7edba0f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPassenger_1_1FileDescriptor.html">FileDescriptor</a> Passenger::EventedClient::detach </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Detaches the client file descriptor so that this <a class="el" href="classPassenger_1_1EventedClient.html" title="A utility class for making I/O handling in non-blocking libev evented servers much...">EventedClient</a> no longer has any control over it. </p>
<p>Any <a class="el" href="classPassenger_1_1EventedClient.html" title="A utility class for making I/O handling in non-blocking libev evented servers much...">EventedClient</a> I/O watchers on the client file descriptor will be stopped and further I/O on the file descriptor via <a class="el" href="classPassenger_1_1EventedClient.html" title="A utility class for making I/O handling in non-blocking libev evented servers much...">EventedClient</a> will become impossible. Any pending outgoing data will be discarded. The original client file descriptor is returned and <code>onDetach</code> is called. Subsequent calls to this function will return -1 and will no longer call <code>onDetach</code>.</p>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>!ioAllowed() </dd>
<dd>
fd == -1 </dd></dl>

</div>
</div>
<a class="anchor" id="a5b1a3011165ea9a47f6fe668a5010a20"></a><!-- doxytag: member="Passenger::EventedClient::disconnect" ref="a5b1a3011165ea9a47f6fe668a5010a20" args="(bool force=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Passenger::EventedClient::disconnect </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>force</em> = <code>false</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Disconnects the client. </p>
<p>This actually closes the underlying file descriptor, even if the <a class="el" href="classPassenger_1_1FileDescriptor.html" title="Wrapper class around a file descriptor integer, for RAII behavior.">FileDescriptor</a> object still has references.</p>
<p>If <em>force</em> is true then the client will be disconnected immediately, and any pending outgoing data will be discarded. Otherwise the client will be disconnected after all pending outgoing data have been sent; in the mean time no new data can be received from or sent to the client.</p>
<p>After the client has actually been disconnected (which may be either immediately or after a short period of time), a disconnect event will be emitted.</p>
<p>If the client connection has already been closed then this method does nothing. If the client connection is being closed (because there's pending outgoing data) then the behavior depends on the <code>force</code> argument: if true then the connection is closed immediately and the pending data is discarded, otherwise this method does nothing.</p>
<p>The <code>onDisconnect</code> callback will be called after the file descriptor is closed, which is either immediately or after all pending data has been sent out. </p>

</div>
</div>
<a class="anchor" id="a50436eb8ec0cc38b5a7278962e98a22c"></a><!-- doxytag: member="Passenger::EventedClient::ioAllowed" ref="a50436eb8ec0cc38b5a7278962e98a22c" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Passenger::EventedClient::ioAllowed </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns whether it is allowed to perform some kind of I/O with this client, either reading or writing. </p>
<p>Usually true, and false when the client is either being disconnected or has been disconnected. A return value of false indicates that <code>fd</code> might be -1, but even when it isn't -1 you shouldn't access <code>fd</code> anymore. When the connection is half-closed (e.g. after <a class="el" href="classPassenger_1_1EventedClient.html#a9161e34ddc473c00fe4df8fdb1d1baef" title="Close only the writer side of the client connection.">closeWrite()</a> has been called) the return value is still be true. Only when I/O of any kind is disallowed will this function return false. </p>

</div>
</div>
<a class="anchor" id="a56ac52f1a4e77c49f72202d16e588f2f"></a><!-- doxytag: member="Passenger::EventedClient::notifyReads" ref="a56ac52f1a4e77c49f72202d16e588f2f" args="(bool enable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Passenger::EventedClient::notifyReads </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>enable</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets whether you're interested in read events. </p>
<p>This will start or stop the input readiness watcher appropriately according to the current state.</p>
<p>If the client connection is already being closed or has already been closed then this method does nothing. </p>

</div>
</div>
<a class="anchor" id="a0a032e54979b074641ffda807648a6e2"></a><!-- doxytag: member="Passenger::EventedClient::pendingWrites" ref="a0a032e54979b074641ffda807648a6e2" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Passenger::EventedClient::pendingWrites </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the number of bytes that are scheduled to be sent to the client at a later time. </p>
<dl class="see"><dt><b>See also:</b></dt><dd>write() </dd></dl>

</div>
</div>
<a class="anchor" id="a129f6d6a6123c9af1999eca4ae04a75a"></a><!-- doxytag: member="Passenger::EventedClient::readWatcherActive" ref="a129f6d6a6123c9af1999eca4ae04a75a" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Passenger::EventedClient::readWatcherActive </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Used by unit tests. </p>

</div>
</div>
<a class="anchor" id="ac1eb48c0d5382a97facbf9af40924849"></a><!-- doxytag: member="Passenger::EventedClient::setOutboxLimit" ref="ac1eb48c0d5382a97facbf9af40924849" args="(unsigned int size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Passenger::EventedClient::setOutboxLimit </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>size</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets a limit on the client outbox. </p>
<p>The outbox is where data is stored that could not be immediately sent to the client, e.g. because of network congestion. Whenver the outbox's size grows past this limit, <a class="el" href="classPassenger_1_1EventedClient.html" title="A utility class for making I/O handling in non-blocking libev evented servers much...">EventedClient</a> will enter a state in which it will stop listening for read events and instead concentrate on sending out all pending data.</p>
<p>Setting this to 0 means that the outbox has an unlimited size. Please note however that this also means that the outbox's memory could grow unbounded if the client is too slow at receiving data.</p>
<p>The default value is some non-zero value.</p>
<p>If the client connection is already being closed or has already been closed then this method does nothing. </p>

</div>
</div>
<a class="anchor" id="a1e480f15dfd339ff781f8daedc5b8190"></a><!-- doxytag: member="Passenger::EventedClient::unref" ref="a1e480f15dfd339ff781f8daedc5b8190" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Passenger::EventedClient::unref </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Decrease reference count. </p>
<p>Upon reaching 0, this <a class="el" href="classPassenger_1_1EventedClient.html" title="A utility class for making I/O handling in non-blocking libev evented servers much...">EventedClient</a> object will be destroyed. </p>

</div>
</div>
<a class="anchor" id="aa07723456786b9f18b973bd88ff51e27"></a><!-- doxytag: member="Passenger::EventedClient::write" ref="aa07723456786b9f18b973bd88ff51e27" args="(const StaticString data[], unsigned int count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Passenger::EventedClient::write </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPassenger_1_1StaticString.html">StaticString</a>&nbsp;</td>
          <td class="paramname"> <em>data</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sends data to this client. </p>
<p>This method will try to send the data immediately (in which no intermediate copies of the data will be made), but if the client is not yet ready to receive data (e.g. because of network congestion) then the data will be buffered and scheduled for sending later.</p>
<p>If an I/O error was encountered then the action taken depends on the value of <em>writeActionError</em>. By default it is DISCONNECT_FULL, meaning the client connection will be closed by calling <code>disconnect(true)</code>. This means this method could potentially call the <code>onDisconnect</code> callback.</p>
<p>If the client connection is already being closed, has already been closed or if the writer side is closed, then this method does nothing.</p>
<p>The <code>onPendingDataFlushed</code> callback will be called after this data and whatever existing pending data have been written out. That may either be immediately or after a short period of of time. </p>

</div>
</div>
<a class="anchor" id="aca719fb03ade09839827a16caa0e6e30"></a><!-- doxytag: member="Passenger::EventedClient::writeAllowed" ref="aca719fb03ade09839827a16caa0e6e30" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Passenger::EventedClient::writeAllowed </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns whether it is allowed to write data to the client. </p>
<p>Usually true, and false when the client is either being disconnected or has been disconnected or when the writer side of the client connection has been closed. write() will do nothing if this function returns false. </p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a4473719c16cae760e1811b7ccb1dc491"></a><!-- doxytag: member="Passenger::EventedClient::fd" ref="a4473719c16cae760e1811b7ccb1dc491" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPassenger_1_1FileDescriptor.html">FileDescriptor</a> <a class="el" href="classPassenger_1_1EventedClient.html#a4473719c16cae760e1811b7ccb1dc491">Passenger::EventedClient::fd</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The client's file descriptor. </p>
<p>Could be -1: see <code><a class="el" href="classPassenger_1_1EventedClient.html#a50436eb8ec0cc38b5a7278962e98a22c" title="Returns whether it is allowed to perform some kind of I/O with this client, either...">ioAllowed()</a></code>. </p>

</div>
</div>
<a class="anchor" id="a211210ecd85eb2da47d200215132bb2d"></a><!-- doxytag: member="Passenger::EventedClient::onDisconnect" ref="a211210ecd85eb2da47d200215132bb2d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Callback <a class="el" href="classPassenger_1_1EventedClient.html#a211210ecd85eb2da47d200215132bb2d">Passenger::EventedClient::onDisconnect</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Called when the client is disconnected. </p>
<p>This happens either immediately when <code><a class="el" href="classPassenger_1_1EventedClient.html#a5b1a3011165ea9a47f6fe668a5010a20" title="Disconnects the client.">disconnect()</a></code> is called, or a short amount of time later. See the documentation for that function for details.</p>
<p>Please note that destroying an <a class="el" href="classPassenger_1_1EventedClient.html" title="A utility class for making I/O handling in non-blocking libev evented servers much...">EventedClient</a> object does *not* cause this callback to be called. </p>

</div>
</div>
<a class="anchor" id="a22e93ce2be05a4f47dbeba95d79a79b9"></a><!-- doxytag: member="Passenger::EventedClient::onPendingDataFlushed" ref="a22e93ce2be05a4f47dbeba95d79a79b9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Callback <a class="el" href="classPassenger_1_1EventedClient.html#a22e93ce2be05a4f47dbeba95d79a79b9">Passenger::EventedClient::onPendingDataFlushed</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Called after all pending outgoing data have been written out. </p>
<p>If <code>write()</code> can be completed immediately without scheduling data for later, then <code>write()</code> will call this callback immediately after writing. </p>

</div>
</div>
<a class="anchor" id="a155988f311fba920bef3031f3d9b6f6a"></a><!-- doxytag: member="Passenger::EventedClient::onReadable" ref="a155988f311fba920bef3031f3d9b6f6a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Callback <a class="el" href="classPassenger_1_1EventedClient.html#a155988f311fba920bef3031f3d9b6f6a">Passenger::EventedClient::onReadable</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Called when the file descriptor becomes readable and read notifications are enabled (see <code>notifyRead()</code>). </p>
<p>When there's too much pending outgoing data, readability notifications are temporarily disabled; see <code>write()</code> for details. </p>

</div>
</div>
<a class="anchor" id="a793c843b7ba01cc1bb2c568c6539b9e0"></a><!-- doxytag: member="Passenger::EventedClient::userData" ref="a793c843b7ba01cc1bb2c568c6539b9e0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="classPassenger_1_1EventedClient.html#a793c843b7ba01cc1bb2c568c6539b9e0">Passenger::EventedClient::userData</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="classPassenger_1_1EventedClient.html" title="A utility class for making I/O handling in non-blocking libev evented servers much...">EventedClient</a> doesn't do anything with this. </p>
<p>Set it to whatever you want. </p>

</div>
</div>
<a class="anchor" id="afc0934988a978a25538b7d8f2566c90a"></a><!-- doxytag: member="Passenger::EventedClient::writeErrorAction" ref="afc0934988a978a25538b7d8f2566c90a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum { ... }   <a class="el" href="classPassenger_1_1EventedClient.html#afc0934988a978a25538b7d8f2566c90a">Passenger::EventedClient::writeErrorAction</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Controls what to do when a write error is encountered. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="EventedClient_8h_source.html">EventedClient.h</a></li>
</ul>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
</body>
</html>
