<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Passenger: Passenger::ScgiRequestParser Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.2 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespacePassenger.html">Passenger</a>::<a class="el" href="classPassenger_1_1ScgiRequestParser.html">ScgiRequestParser</a>
  </div>
</div>
<div class="contents">
<h1>Passenger::ScgiRequestParser Class Reference</h1><!-- doxytag: class="Passenger::ScgiRequestParser" -->
<p>A parser for SCGI requests.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="ScgiRequestParser_8h_source.html">ScgiRequestParser.h</a>&gt;</code></p>

<p><a href="classPassenger_1_1ScgiRequestParser-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1ScgiRequestParser.html#a495e2aec6deffd64fd3d53dc81379f8b">ErrorReason</a> { , <br/>
&nbsp;&nbsp;<a class="el" href="classPassenger_1_1ScgiRequestParser.html#a495e2aec6deffd64fd3d53dc81379f8ba9ba3d5851af9ffae1e9202bc9f73ac5b">LENGTH_STRING_TOO_LARGE</a>, 
<a class="el" href="classPassenger_1_1ScgiRequestParser.html#a495e2aec6deffd64fd3d53dc81379f8ba876574447523322b9d7b4921e490032d">LIMIT_REACHED</a>, 
<a class="el" href="classPassenger_1_1ScgiRequestParser.html#a495e2aec6deffd64fd3d53dc81379f8bafe61dd339024beaed48f6eed6e6f3332">INVALID_LENGTH_STRING</a>, 
<a class="el" href="classPassenger_1_1ScgiRequestParser.html#a495e2aec6deffd64fd3d53dc81379f8ba44078eaf2ae1ee592d65d122dbda4a44">HEADER_TERMINATOR_EXPECTED</a>, 
<br/>
&nbsp;&nbsp;<a class="el" href="classPassenger_1_1ScgiRequestParser.html#a495e2aec6deffd64fd3d53dc81379f8bac162062c109fe310d5923d12b6147add">INVALID_HEADER_DATA</a>
<br/>
 }</td></tr>
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1ScgiRequestParser.html#a1108e7ce9162289db8a5b14479325e7a">ScgiRequestParser</a> (unsigned long maxSize=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new <a class="el" href="classPassenger_1_1ScgiRequestParser.html" title="A parser for SCGI requests.">ScgiRequestParser</a>, ready to parse a request.  <a href="#a1108e7ce9162289db8a5b14479325e7a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1ScgiRequestParser.html#a0498c9529029969d5a77e1f74f95baa3">feed</a> (const char *data, unsigned int size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Feed SCGI request data to the parser.  <a href="#a0498c9529029969d5a77e1f74f95baa3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa96dbb7c4c642ac74f30ed5b14a64e86"></a><!-- doxytag: member="Passenger::ScgiRequestParser::getHeaderData" ref="aa96dbb7c4c642ac74f30ed5b14a64e86" args="() const " -->
string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1ScgiRequestParser.html#aa96dbb7c4c642ac74f30ed5b14a64e86">getHeaderData</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the raw header data that has been processed so far. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPassenger_1_1StaticString.html">StaticString</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1ScgiRequestParser.html#a82321480ad2f8ac7ba58ff865131f6b4">getHeader</a> (const <a class="el" href="classPassenger_1_1StaticString.html">StaticString</a> &amp;name) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the value of the header with the given name.  <a href="#a82321480ad2f8ac7ba58ff865131f6b4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1ScgiRequestParser.html#ad82e358a0ad051ab2bdd2374e9ab4ff8">hasHeader</a> (const <a class="el" href="classPassenger_1_1StaticString.html">StaticString</a> &amp;name) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks whether there is a header with the given name.  <a href="#ad82e358a0ad051ab2bdd2374e9ab4ff8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5bd7dbce81c69ae9e3462e84daf09012"></a><!-- doxytag: member="Passenger::ScgiRequestParser::getState" ref="a5bd7dbce81c69ae9e3462e84daf09012" args="() const " -->
State&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1ScgiRequestParser.html#a5bd7dbce81c69ae9e3462e84daf09012">getState</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the parser's current state. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPassenger_1_1ScgiRequestParser.html#a495e2aec6deffd64fd3d53dc81379f8b">ErrorReason</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1ScgiRequestParser.html#a4114253f47d3e7e5c0dddc3cd11c5596">getErrorReason</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the reason why the parser entered the error state.  <a href="#a4114253f47d3e7e5c0dddc3cd11c5596"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5368ed40bf7c896f68d7ffaae164a092"></a><!-- doxytag: member="Passenger::ScgiRequestParser::acceptingInput" ref="a5368ed40bf7c896f68d7ffaae164a092" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1ScgiRequestParser.html#a5368ed40bf7c896f68d7ffaae164a092">acceptingInput</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks whether this parser is still capable of accepting input (that is, that this parser is not in a final state). <br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>A parser for SCGI requests. </p>
<p>It parses the request header and ignores the body data.</p>
<p>You can use it by constructing a parser object, then feeding data to the parser until it has reached a final state.</p>
<p>Example: </p>
<div class="fragment"><pre class="fragment">    <a class="code" href="classPassenger_1_1ScgiRequestParser.html#a1108e7ce9162289db8a5b14479325e7a" title="Create a new ScgiRequestParser, ready to parse a request.">ScgiRequestParser</a> parser;
    <span class="keywordtype">char</span> buf[1024 * 16];
    ssize_t size;
    <span class="keywordtype">unsigned</span> in bytesAccepted;
    
    <span class="keywordflow">do</span> {
        size = read(fd, buf, <span class="keyword">sizeof</span>(buf));
        bytesAccepted = parser.feed(buf, size);
    } <span class="keywordflow">while</span> (parser.acceptingInput());
    <span class="comment">// Parser is done when its return value isn&#39;t equal to the input size.</span>
    
    <span class="comment">// Check whether a parse error occured.</span>
    <span class="keywordflow">if</span> (parser.getState() == ScgiRequestParser::ERROR) {
        bailOut();
    } <span class="keywordflow">else</span> {
        <span class="comment">// All good! Do something with the SCGI header that the parser parsed.</span>
        processHeader(parser.getHeaderData());
        
        <span class="comment">// If the last buffer passed to the parser also contains body data,</span>
        <span class="comment">// then the body data starts at &#39;buf + bytesAccepted&#39;.</span>
        <span class="keywordflow">if</span> (bytesAccepted &lt; size) {
            processBody(buf + bytesAccepted);
        }
        <span class="keywordflow">while</span> (!end_of_file(fd)) {
            ... read(...) ...
            processBody(...);
        }
    }
</pre></div><p>Parser properties:</p>
<ul>
<li>A parser object can only process a single SCGI request. You must discard the existing parser object and create a new one if you want to process another SCGI request.</li>
<li>This parser checks whether the header netstring is valid. It will enter the error state if it encounters a parse error.</li>
<li>However, this parser does not perform any validation of the actual header contents. For example, it doesn't check that CONTENT_LENGTH is the first header, or that the SCGI header is present. </li>
</ul>
<hr/><h2>Member Enumeration Documentation</h2>
<a class="anchor" id="a495e2aec6deffd64fd3d53dc81379f8b"></a><!-- doxytag: member="Passenger::ScgiRequestParser::ErrorReason" ref="a495e2aec6deffd64fd3d53dc81379f8b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classPassenger_1_1ScgiRequestParser.html#a495e2aec6deffd64fd3d53dc81379f8b">Passenger::ScgiRequestParser::ErrorReason</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a495e2aec6deffd64fd3d53dc81379f8ba9ba3d5851af9ffae1e9202bc9f73ac5b"></a><!-- doxytag: member="LENGTH_STRING_TOO_LARGE" ref="a495e2aec6deffd64fd3d53dc81379f8ba9ba3d5851af9ffae1e9202bc9f73ac5b" args="" -->LENGTH_STRING_TOO_LARGE</em>&nbsp;</td><td>
<p>The length string is too large. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a495e2aec6deffd64fd3d53dc81379f8ba876574447523322b9d7b4921e490032d"></a><!-- doxytag: member="LIMIT_REACHED" ref="a495e2aec6deffd64fd3d53dc81379f8ba876574447523322b9d7b4921e490032d" args="" -->LIMIT_REACHED</em>&nbsp;</td><td>
<p>The header is larger than the maxSize value provided to the constructor. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a495e2aec6deffd64fd3d53dc81379f8bafe61dd339024beaed48f6eed6e6f3332"></a><!-- doxytag: member="INVALID_LENGTH_STRING" ref="a495e2aec6deffd64fd3d53dc81379f8bafe61dd339024beaed48f6eed6e6f3332" args="" -->INVALID_LENGTH_STRING</em>&nbsp;</td><td>
<p>The length string contains an invalid character. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a495e2aec6deffd64fd3d53dc81379f8ba44078eaf2ae1ee592d65d122dbda4a44"></a><!-- doxytag: member="HEADER_TERMINATOR_EXPECTED" ref="a495e2aec6deffd64fd3d53dc81379f8ba44078eaf2ae1ee592d65d122dbda4a44" args="" -->HEADER_TERMINATOR_EXPECTED</em>&nbsp;</td><td>
<p>A header terminator character (",") was expected, but some else was encountered instead. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a495e2aec6deffd64fd3d53dc81379f8bac162062c109fe310d5923d12b6147add"></a><!-- doxytag: member="INVALID_HEADER_DATA" ref="a495e2aec6deffd64fd3d53dc81379f8bac162062c109fe310d5923d12b6147add" args="" -->INVALID_HEADER_DATA</em>&nbsp;</td><td>
<p>The header data itself contains errors. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a1108e7ce9162289db8a5b14479325e7a"></a><!-- doxytag: member="Passenger::ScgiRequestParser::ScgiRequestParser" ref="a1108e7ce9162289db8a5b14479325e7a" args="(unsigned long maxSize=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Passenger::ScgiRequestParser::ScgiRequestParser </td>
          <td>(</td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>maxSize</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new <a class="el" href="classPassenger_1_1ScgiRequestParser.html" title="A parser for SCGI requests.">ScgiRequestParser</a>, ready to parse a request. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>maxSize</em>&nbsp;</td><td>The maximum size that the SCGI data is allowed to be, or 0 if no limit is desired. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a0498c9529029969d5a77e1f74f95baa3"></a><!-- doxytag: member="Passenger::ScgiRequestParser::feed" ref="a0498c9529029969d5a77e1f74f95baa3" args="(const char *data, unsigned int size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Passenger::ScgiRequestParser::feed </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Feed SCGI request data to the parser. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>The data to feed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>The size of the data, in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of recognized SCGI header bytes. If this value equals 'size', then it means all data in 'data' is part of the SCGI header. If this value is less than size, then it means only some data in 'data' is part of the SCGI header, and the remaining 'size - result' bytes are part of the request body. </dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>size &gt; 0 </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>result &lt;= size </dd>
<dd>
if result &lt;= size: <a class="el" href="classPassenger_1_1ScgiRequestParser.html#a5bd7dbce81c69ae9e3462e84daf09012" title="Get the parser&#39;s current state.">getState()</a> == DONE || <a class="el" href="classPassenger_1_1ScgiRequestParser.html#a5bd7dbce81c69ae9e3462e84daf09012" title="Get the parser&#39;s current state.">getState()</a> == ERROR </dd></dl>

</div>
</div>
<a class="anchor" id="a4114253f47d3e7e5c0dddc3cd11c5596"></a><!-- doxytag: member="Passenger::ScgiRequestParser::getErrorReason" ref="a4114253f47d3e7e5c0dddc3cd11c5596" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPassenger_1_1ScgiRequestParser.html#a495e2aec6deffd64fd3d53dc81379f8b">ErrorReason</a> Passenger::ScgiRequestParser::getErrorReason </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the reason why the parser entered the error state. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><a class="el" href="classPassenger_1_1ScgiRequestParser.html#a5bd7dbce81c69ae9e3462e84daf09012" title="Get the parser&#39;s current state.">getState()</a> == ERROR </dd></dl>

</div>
</div>
<a class="anchor" id="a82321480ad2f8ac7ba58ff865131f6b4"></a><!-- doxytag: member="Passenger::ScgiRequestParser::getHeader" ref="a82321480ad2f8ac7ba58ff865131f6b4" args="(const StaticString &amp;name) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPassenger_1_1StaticString.html">StaticString</a> Passenger::ScgiRequestParser::getHeader </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPassenger_1_1StaticString.html">StaticString</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the value of the header with the given name. </p>
<p>Lookup is case-sensitive.</p>
<p>Returns the empty string if there is no such header.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><a class="el" href="classPassenger_1_1ScgiRequestParser.html#a5bd7dbce81c69ae9e3462e84daf09012" title="Get the parser&#39;s current state.">getState()</a> == DONE </dd></dl>

</div>
</div>
<a class="anchor" id="ad82e358a0ad051ab2bdd2374e9ab4ff8"></a><!-- doxytag: member="Passenger::ScgiRequestParser::hasHeader" ref="ad82e358a0ad051ab2bdd2374e9ab4ff8" args="(const StaticString &amp;name) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Passenger::ScgiRequestParser::hasHeader </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPassenger_1_1StaticString.html">StaticString</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks whether there is a header with the given name. </p>
<p>Lookup is case-sensitive.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><a class="el" href="classPassenger_1_1ScgiRequestParser.html#a5bd7dbce81c69ae9e3462e84daf09012" title="Get the parser&#39;s current state.">getState()</a> == DONE </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="ScgiRequestParser_8h_source.html">ScgiRequestParser.h</a></li>
</ul>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
</body>
</html>
