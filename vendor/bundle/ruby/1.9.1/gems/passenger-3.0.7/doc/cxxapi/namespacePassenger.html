<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Passenger: Passenger Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.2 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="namespaces.html"><span>Namespace&nbsp;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Passenger Namespace Reference</h1>
<p>Common code for all agents.  
<a href="#_details">More...</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1DirectoryMapper.html">DirectoryMapper</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Utility class for determining URI-to-application directory mappings.  <a href="classPassenger_1_1DirectoryMapper.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1AbstractSpawnManager.html">AbstractSpawnManager</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Spawning of application processes.  <a href="classPassenger_1_1AbstractSpawnManager.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1EventedClient.html">EventedClient</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A utility class for making I/O handling in non-blocking libev evented servers much easier.  <a href="classPassenger_1_1EventedClient.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1EventedMessageServer.html">EventedMessageServer</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Note when overriding onNewClient: call the parent method first! It does some initialization but might disconnect the client if that initialization fails.  <a href="classPassenger_1_1EventedMessageServer.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1EventedServer.html">EventedServer</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A base class for writing single-threaded, evented servers that use non-blocking I/O.  <a href="classPassenger_1_1EventedServer.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1SystemException.html">SystemException</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Represents an error returned by a system call or a standard library call.  <a href="classPassenger_1_1SystemException.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1FileSystemException.html">FileSystemException</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A filesystem error, as returned by the operating system.  <a href="classPassenger_1_1FileSystemException.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1TimeRetrievalException.html">TimeRetrievalException</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unable to retrieve the system time using <code>time()</code>.  <a href="classPassenger_1_1TimeRetrievalException.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1IOException.html">IOException</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Represents an error that occured during an I/O operation.  <a href="classPassenger_1_1IOException.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1FileNotFoundException.html">FileNotFoundException</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Thrown when a certain file cannot be found.  <a href="classPassenger_1_1FileNotFoundException.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1EOFException.html">EOFException</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An unexpected end-of-file I/O error.  <a href="classPassenger_1_1EOFException.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1ConfigurationException.html">ConfigurationException</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Thrown when an invalid configuration is given.  <a href="classPassenger_1_1ConfigurationException.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1SpawnException.html">SpawnException</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Thrown when <a class="el" href="classPassenger_1_1SpawnManager.html" title="An AbstractSpawnManager implementation.">SpawnManager</a> or ApplicationPool fails to spawn an application instance.  <a href="classPassenger_1_1SpawnException.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1ArgumentException.html">ArgumentException</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Indicates that a specified argument is incorrect or violates a requirement.  <a href="classPassenger_1_1ArgumentException.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1RuntimeException.html">RuntimeException</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A generic runtime exception.  <a href="classPassenger_1_1RuntimeException.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1TimeoutException.html">TimeoutException</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An exception indicating that some timeout expired.  <a href="classPassenger_1_1TimeoutException.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1SecurityException.html">SecurityException</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Represents some kind of security error.  <a href="classPassenger_1_1SecurityException.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1BusyException.html">BusyException</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The application pool is too busy and cannot fulfill a get() request.  <a href="classPassenger_1_1BusyException.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1SyntaxError.html">SyntaxError</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A parser detected a syntax error.  <a href="classPassenger_1_1SyntaxError.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1FileDescriptor.html">FileDescriptor</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wrapper class around a file descriptor integer, for RAII behavior.  <a href="classPassenger_1_1FileDescriptor.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1FileDescriptorPair.html">FileDescriptorPair</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A structure containing two <a class="el" href="classPassenger_1_1FileDescriptor.html" title="Wrapper class around a file descriptor integer, for RAII behavior.">FileDescriptor</a> objects.  <a href="classPassenger_1_1FileDescriptorPair.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1EventFd.html">EventFd</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A synchronization mechanism that's implemented with file descriptors, and as such can be used in combination with select() and friends.  <a href="classPassenger_1_1EventFd.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1MessageChannel.html">MessageChannel</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience class for I/O operations on file descriptors.  <a href="classPassenger_1_1MessageChannel.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1Uint16Message.html">Uint16Message</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">For 16-bit big-endian integers.  <a href="classPassenger_1_1Uint16Message.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1Uint32Message.html">Uint32Message</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">For 32-bit big-endian integers.  <a href="classPassenger_1_1Uint32Message.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1ArrayMessage.html">ArrayMessage</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">For array messages.  <a href="classPassenger_1_1ArrayMessage.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1ScalarMessage.html">ScalarMessage</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class for reading a scalar message.  <a href="classPassenger_1_1ScalarMessage.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1MessageServer.html">MessageServer</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Simple pluggable request/response messaging server framework.  <a href="classPassenger_1_1MessageServer.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPassenger_1_1PoolOptions.html">PoolOptions</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This struct encapsulates information for ApplicationPool::get() and for <a class="el" href="classPassenger_1_1SpawnManager.html#a88a94ba4d41dab492cb1dc8a0f998973" title="Spawn a new application process.">SpawnManager::spawn()</a>, such as which application is to be spawned.  <a href="structPassenger_1_1PoolOptions.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1Process.html">Process</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Represents a single application process, as spawned by <a class="el" href="classPassenger_1_1SpawnManager.html" title="An AbstractSpawnManager implementation.">SpawnManager</a> or by ApplicationPool::Interface::get().  <a href="classPassenger_1_1Process.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1RandomGenerator.html">RandomGenerator</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A random data generator.  <a href="classPassenger_1_1RandomGenerator.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1ResourceLocator.html">ResourceLocator</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Locates various Phusion <a class="el" href="namespacePassenger.html" title="Common code for all agents.">Passenger</a> resources on the filesystem.  <a href="classPassenger_1_1ResourceLocator.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1SafeLibev.html">SafeLibev</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class for thread-safely using libev.  <a href="classPassenger_1_1SafeLibev.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1Session.html">Session</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Represents a single request/response pair of an application process.  <a href="classPassenger_1_1Session.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1StandardSession.html">StandardSession</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A "standard" implementation of <a class="el" href="classPassenger_1_1Session.html" title="Represents a single request/response pair of an application process.">Session</a>.  <a href="classPassenger_1_1StandardSession.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1SpawnManager.html">SpawnManager</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An <a class="el" href="classPassenger_1_1AbstractSpawnManager.html" title="Spawning of application processes.">AbstractSpawnManager</a> implementation.  <a href="classPassenger_1_1SpawnManager.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1StaticString.html">StaticString</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An immutable, static byte buffer.  <a href="classPassenger_1_1StaticString.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1BufferedUpload.html">BufferedUpload</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Represents a buffered upload file.  <a href="classPassenger_1_1BufferedUpload.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1HttpStatusExtractor.html">HttpStatusExtractor</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Utility class for extracting the HTTP status value from an HTTP response.  <a href="classPassenger_1_1HttpStatusExtractor.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1ScgiRequestParser.html">ScgiRequestParser</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A parser for SCGI requests.  <a href="classPassenger_1_1ScgiRequestParser.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef shared_ptr<br class="typebreak"/>
&lt; <a class="el" href="classPassenger_1_1AbstractSpawnManager.html">AbstractSpawnManager</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePassenger.html#afd60d942a89fbb7f306e330d75704570">AbstractSpawnManagerPtr</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenient alias for <a class="el" href="classPassenger_1_1AbstractSpawnManager.html" title="Spawning of application processes.">AbstractSpawnManager</a> smart pointer.  <a href="#afd60d942a89fbb7f306e330d75704570"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef shared_ptr&lt; <a class="el" href="classPassenger_1_1Process.html">Process</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePassenger.html#aced1f248465136b313c6dec5fe6ca492">ProcessPtr</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenient alias for <a class="el" href="classPassenger_1_1Process.html" title="Represents a single application process, as spawned by SpawnManager or by ApplicationPool::Interface...">Process</a> smart pointer.  <a href="#aced1f248465136b313c6dec5fe6ca492"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef shared_ptr&lt; <a class="el" href="classPassenger_1_1SpawnManager.html">SpawnManager</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePassenger.html#a6ab2d566ff87a2676c23d8aa40204587">SpawnManagerPtr</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenient alias for <a class="el" href="classPassenger_1_1SpawnManager.html" title="An AbstractSpawnManager implementation.">SpawnManager</a> smart pointer.  <a href="#a6ab2d566ff87a2676c23d8aa40204587"></a><br/></td></tr>
<tr><td colspan="2"><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePassenger.html#a14174b712df6046cb823cde43d7ef07d">FileType</a> { <a class="el" href="namespacePassenger.html#a14174b712df6046cb823cde43d7ef07da9fc66834fe96c52799397496b8df8486">FT_NONEXISTANT</a>, 
<a class="el" href="namespacePassenger.html#a14174b712df6046cb823cde43d7ef07da1538596a928321d1a282c6bb06e80563">FT_REGULAR</a>, 
<a class="el" href="namespacePassenger.html#a14174b712df6046cb823cde43d7ef07dabb09dbba1071b4770913363db2462eee">FT_DIRECTORY</a>, 
<a class="el" href="namespacePassenger.html#a14174b712df6046cb823cde43d7ef07da3e89b9a7be074975e007d9f7cd77f4ff">FT_OTHER</a>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Enumeration which indicates what kind of file a file is. </p>
 <a href="namespacePassenger.html#a14174b712df6046cb823cde43d7ef07d">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">apr_bucket *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePassenger.html#a35b11c8ce90e90d01380f182d82f8cac">passenger_bucket_create</a> (SessionPtr session, PassengerBucketStatePtr state, apr_bucket_alloc_t *list)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">We used to use an apr_bucket_pipe for forwarding the backend process's response to the HTTP client.  <a href="#a35b11c8ce90e90d01380f182d82f8cac"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Support.html#ga2a62e38a72c6c65992e3361f6d80c7ef">fileExists</a> (const <a class="el" href="classPassenger_1_1StaticString.html">StaticString</a> &amp;filename, CachedFileStat *cstat=0, unsigned int throttleRate=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check whether the specified file exists.  <a href="group__Support.html#ga2a62e38a72c6c65992e3361f6d80c7ef"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacePassenger.html#a14174b712df6046cb823cde43d7ef07d">FileType</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Support.html#ga15298b031377d3ecb80295bd5b1a8180">getFileType</a> (const <a class="el" href="classPassenger_1_1StaticString.html">StaticString</a> &amp;filename, CachedFileStat *cstat=0, unsigned int throttleRate=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check whether 'filename' exists and what kind of file it is.  <a href="group__Support.html#ga15298b031377d3ecb80295bd5b1a8180"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Support.html#ga6f414070373465da2e12947463f69953">createFile</a> (const string &amp;filename, const <a class="el" href="classPassenger_1_1StaticString.html">StaticString</a> &amp;contents, mode_t permissions=S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH, uid_t owner=USER_NOT_GIVEN, gid_t group=GROUP_NOT_GIVEN, bool overwrite=true)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create the given file with the given contents, permissions and ownership.  <a href="group__Support.html#ga6f414070373465da2e12947463f69953"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Support.html#gaf3b0a483f0a252ae08d9de9f8b267d36">canonicalizePath</a> (const string &amp;path)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a canonical version of the specified path.  <a href="group__Support.html#gaf3b0a483f0a252ae08d9de9f8b267d36"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Support.html#gac3d2b3d608188527d888e63d22c5163c">resolveSymlink</a> (const string &amp;path)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If <em>path</em> refers to a symlink, then this function resolves the symlink for 1 level.  <a href="group__Support.html#gac3d2b3d608188527d888e63d22c5163c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae651ece5281f22dc5fc974079f7c9187"></a><!-- doxytag: member="Passenger::extractDirName" ref="gae651ece5281f22dc5fc974079f7c9187" args="(const StaticString &amp;path)" -->
string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Support.html#gae651ece5281f22dc5fc974079f7c9187">extractDirName</a> (const <a class="el" href="classPassenger_1_1StaticString.html">StaticString</a> &amp;path)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Given a path, extracts its directory name. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaeb750234207485fa57609174ca8d4359"></a><!-- doxytag: member="Passenger::extractBaseName" ref="gaeb750234207485fa57609174ca8d4359" args="(const StaticString &amp;path)" -->
string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Support.html#gaeb750234207485fa57609174ca8d4359">extractBaseName</a> (const <a class="el" href="classPassenger_1_1StaticString.html">StaticString</a> &amp;path)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Given a path, extracts its base name. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Support.html#gae74addedf73782a1eb1f6dd48d6fce06">escapeForXml</a> (const string &amp;input)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Escape the given raw string into an XML value.  <a href="group__Support.html#gae74addedf73782a1eb1f6dd48d6fce06"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePassenger.html#ade80218e8b836b796f8b960b6225b439">getProcessUsername</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the username of the user that the current process is running as.  <a href="#ade80218e8b836b796f8b960b6225b439"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">mode_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePassenger.html#ada53f5a9bdcf3d22d4a710e7ea3678e9">parseModeString</a> (const <a class="el" href="classPassenger_1_1StaticString.html">StaticString</a> &amp;mode)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts a mode string into a mode_t value.  <a href="#ada53f5a9bdcf3d22d4a710e7ea3678e9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Support.html#ga68f4105c5a8e510520b5ea3eecb66213">getSystemTempDir</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the path name for the directory in which the system stores general temporary files.  <a href="group__Support.html#ga68f4105c5a8e510520b5ea3eecb66213"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePassenger.html#a448f25263af0b37b91caee3d294ec4aa">makeDirTree</a> (const string &amp;path, const <a class="el" href="classPassenger_1_1StaticString.html">StaticString</a> &amp;mode=&quot;u=rwx,g=,o=&quot;, uid_t owner=USER_NOT_GIVEN, gid_t group=GROUP_NOT_GIVEN)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create the directory at the given path, creating intermediate directories if necessary.  <a href="#a448f25263af0b37b91caee3d294ec4aa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePassenger.html#a8422d210cbd2f62d21254415b5a7f747">removeDirTree</a> (const string &amp;path)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove an entire directory tree recursively.  <a href="#a8422d210cbd2f62d21254415b5a7f747"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Support.html#ga5e6bc7ff22b7c61238d7913521936f71">verifyRailsDir</a> (const string &amp;dir, CachedFileStat *cstat=0, unsigned int throttleRate=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check whether the specified directory is a valid Ruby on Rails application root directory.  <a href="group__Support.html#ga5e6bc7ff22b7c61238d7913521936f71"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Support.html#ga53969f8e3ee68d1d99ffe75af8db9be8">verifyRackDir</a> (const string &amp;dir, CachedFileStat *cstat=0, unsigned int throttleRate=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check whether the specified directory is a valid Rack application root directory.  <a href="group__Support.html#ga53969f8e3ee68d1d99ffe75af8db9be8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Support.html#gaaec51d2912999d611994c49341f36247">verifyWSGIDir</a> (const string &amp;dir, CachedFileStat *cstat=0, unsigned int throttleRate=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check whether the specified directory is a valid WSGI application root directory.  <a href="group__Support.html#gaaec51d2912999d611994c49341f36247"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePassenger.html#ad233ce971fa0e937182c637bf2d1f105">runAndPrintExceptions</a> (const function&lt; void()&gt; &amp;func, bool toAbort)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Runs the given function and catches any tracable_exceptions.  <a href="#ad233ce971fa0e937182c637bf2d1f105"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePassenger.html#a1d0a66b0e207c46dc6124ff3b2f331e6">getHostName</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the system's host name.  <a href="#a1d0a66b0e207c46dc6124ff3b2f331e6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a979cb43cef743bf261c329b13e712366"></a><!-- doxytag: member="Passenger::getSignalName" ref="a979cb43cef743bf261c329b13e712366" args="(int sig)" -->
string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePassenger.html#a979cb43cef743bf261c329b13e712366">getSignalName</a> (int sig)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert a signal number to its associated name. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePassenger.html#a2029ad8cb57611ab161b20ef9df39c86">resetSignalHandlersAndMask</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resets the current process's signal handler disposition and signal mask to default values.  <a href="#a2029ad8cb57611ab161b20ef9df39c86"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePassenger.html#af116b11276c90901729b6ce541dd2a07">closeAllFileDescriptors</a> (int lastToKeepOpen)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Close all file descriptors that are higher than <em>lastToKeepOpen</em>.  <a href="#af116b11276c90901729b6ce541dd2a07"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">shared_ptr&lt; T &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Support.html#ga41b6c4a82fed72531a147de0505a8396">ptr</a> (T *pointer)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience shortcut for creating a <code>shared_ptr</code>.  <a href="group__Support.html#ga41b6c4a82fed72531a147de0505a8396"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Common code for all agents. </p>
<p>A random.</p>
<p>This file provides a bunch of classes for reading and writing messages in the <a class="el" href="classPassenger_1_1MessageChannel.html" title="Convenience class for I/O operations on file descriptors.">MessageChannel</a> format.</p>
<p>Unlike <a class="el" href="classPassenger_1_1MessageChannel.html" title="Convenience class for I/O operations on file descriptors.">MessageChannel</a>, whose operations take control over the I/O handle and may block, these classes act like parsers and data generators. To read messages one must feed data to them. To write messages one must instruct the classes to generate a bunch of data. These classes will never block, making them ideal for use in evented servers.</p>
<h2>Reading messages</h2>
<p>To read a single message, one must instantiate a message object and feed network data to it with the feed() method. This method returns the number of bytes actually processed by the message object (i.e. the number of bytes that it has recognized as part of the message).</p>
<p>When the message object has either successfully parsed the data or encountered an error, it will indicate so via the done() method. With hasError() one can check whether an error was encountered or whether the reader succeeded, and with errorCode() one can obtain the exact error reason. Not all message objects support hasError() and errorCode() because some of them can never encounter errors and some of them can only fail for a single reason.</p>
<p>When successful, the parsed message can be obtained with value(). This method may only be called when done() is true and there is no error, otherwise the return value is undefined.</p>
<p>At this point, the message object cannot process any more data and feed() will always return 0. To reuse the object for processing another message, one must reset its state by calling reset().</p>
<p>The following example demonstrates how to read a continuous stream of 32-bit integers: </p>
<div class="fragment"><pre class="fragment">   Uint32Message intMessage;
   <span class="keywordflow">while</span> (<span class="keyword">true</span>) {
       <span class="comment">// Read a bunch of network data...</span>
       <span class="keywordtype">char</span> buf[1024];
       ssize_t size = recv(fd, buf, <span class="keyword">sizeof</span>(buf));
       <span class="keywordtype">size_t</span> consumed = 0;
       
       <span class="comment">// ...and process it all. We only feed data to the message object</span>
       <span class="comment">// that hasn&#39;t already been fed.</span>
       <span class="keywordflow">while</span> (consumed &lt; size) {
           consumed += intReader.feed(buf + consumed, size - consumed);
           <span class="keywordflow">if</span> (intMessage.done()) {
               printf(<span class="stringliteral">&quot;Integer: %d\n&quot;</span>, (<span class="keywordtype">int</span>) intMessage.value());
               <span class="comment">// The state must be reset before the reader can be reused.</span>
               intMessage.reset();
           }
       }
   }
</pre></div><p>Some message objects return non-primitive values in their value() methods, such as <a class="el" href="classPassenger_1_1ArrayMessage.html" title="For array messages.">ArrayMessage</a> and <a class="el" href="classPassenger_1_1ScalarMessage.html" title="Class for reading a scalar message.">ScalarMessage</a> which return <code>const vector&lt;StaticString&gt; &amp;</code> and <code><a class="el" href="classPassenger_1_1StaticString.html" title="An immutable, static byte buffer.">StaticString</a></code>, respectively. These values are only valid until either of the following things occur:</p>
<ul>
<li>The buffer containing last the fed data has been destroyed or modified.</li>
<li>The message object itself has been destroyed.</li>
</ul>
<p>This is because the message objects try to apply copy-zero optimizations whenever possible. For example, in case of <a class="el" href="classPassenger_1_1ScalarMessage.html" title="Class for reading a scalar message.">ScalarMessage</a>, it'll check whether the data that has been fed in the first feed() call already contains a full scalar message. If so then it'll just return a <a class="el" href="classPassenger_1_1StaticString.html" title="An immutable, static byte buffer.">StaticString</a> that points to the scalar message in the fed data; it will not copy the fed data. In this case it is important that the buffer containing the fed data is not modified or destroyed while the <a class="el" href="classPassenger_1_1StaticString.html" title="An immutable, static byte buffer.">StaticString</a> is in use. If the first feed() call does not supply a full scalar message then it will buffer all fed data until the buffer contains a full scalar message, and the result will point to this buffer. Because the buffer is owned by the message object, the result will be invalidated as soon as the message object is destroyed. </p>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="afd60d942a89fbb7f306e330d75704570"></a><!-- doxytag: member="Passenger::AbstractSpawnManagerPtr" ref="afd60d942a89fbb7f306e330d75704570" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef shared_ptr&lt;<a class="el" href="classPassenger_1_1AbstractSpawnManager.html">AbstractSpawnManager</a>&gt; <a class="el" href="namespacePassenger.html#afd60d942a89fbb7f306e330d75704570">Passenger::AbstractSpawnManagerPtr</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convenient alias for <a class="el" href="classPassenger_1_1AbstractSpawnManager.html" title="Spawning of application processes.">AbstractSpawnManager</a> smart pointer. </p>

</div>
</div>
<a class="anchor" id="aced1f248465136b313c6dec5fe6ca492"></a><!-- doxytag: member="Passenger::ProcessPtr" ref="aced1f248465136b313c6dec5fe6ca492" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef shared_ptr&lt;<a class="el" href="classPassenger_1_1Process.html">Process</a>&gt; <a class="el" href="namespacePassenger.html#aced1f248465136b313c6dec5fe6ca492">Passenger::ProcessPtr</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convenient alias for <a class="el" href="classPassenger_1_1Process.html" title="Represents a single application process, as spawned by SpawnManager or by ApplicationPool::Interface...">Process</a> smart pointer. </p>

</div>
</div>
<a class="anchor" id="a6ab2d566ff87a2676c23d8aa40204587"></a><!-- doxytag: member="Passenger::SpawnManagerPtr" ref="a6ab2d566ff87a2676c23d8aa40204587" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef shared_ptr&lt;<a class="el" href="classPassenger_1_1SpawnManager.html">SpawnManager</a>&gt; <a class="el" href="namespacePassenger.html#a6ab2d566ff87a2676c23d8aa40204587">Passenger::SpawnManagerPtr</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convenient alias for <a class="el" href="classPassenger_1_1SpawnManager.html" title="An AbstractSpawnManager implementation.">SpawnManager</a> smart pointer. </p>

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="a14174b712df6046cb823cde43d7ef07d"></a><!-- doxytag: member="Passenger::FileType" ref="a14174b712df6046cb823cde43d7ef07d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacePassenger.html#a14174b712df6046cb823cde43d7ef07d">Passenger::FileType</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enumeration which indicates what kind of file a file is. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a14174b712df6046cb823cde43d7ef07da9fc66834fe96c52799397496b8df8486"></a><!-- doxytag: member="FT_NONEXISTANT" ref="a14174b712df6046cb823cde43d7ef07da9fc66834fe96c52799397496b8df8486" args="" -->FT_NONEXISTANT</em>&nbsp;</td><td>
<p>The file doesn't exist. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a14174b712df6046cb823cde43d7ef07da1538596a928321d1a282c6bb06e80563"></a><!-- doxytag: member="FT_REGULAR" ref="a14174b712df6046cb823cde43d7ef07da1538596a928321d1a282c6bb06e80563" args="" -->FT_REGULAR</em>&nbsp;</td><td>
<p>A regular file or a symlink to a regular file. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a14174b712df6046cb823cde43d7ef07dabb09dbba1071b4770913363db2462eee"></a><!-- doxytag: member="FT_DIRECTORY" ref="a14174b712df6046cb823cde43d7ef07dabb09dbba1071b4770913363db2462eee" args="" -->FT_DIRECTORY</em>&nbsp;</td><td>
<p>A directory. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a14174b712df6046cb823cde43d7ef07da3e89b9a7be074975e007d9f7cd77f4ff"></a><!-- doxytag: member="FT_OTHER" ref="a14174b712df6046cb823cde43d7ef07da3e89b9a7be074975e007d9f7cd77f4ff" args="" -->FT_OTHER</em>&nbsp;</td><td>
<p>Something else, e.g. </p>
<p>a pipe or a socket. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="af116b11276c90901729b6ce541dd2a07"></a><!-- doxytag: member="Passenger::closeAllFileDescriptors" ref="af116b11276c90901729b6ce541dd2a07" args="(int lastToKeepOpen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Passenger::closeAllFileDescriptors </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>lastToKeepOpen</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Close all file descriptors that are higher than <em>lastToKeepOpen</em>. </p>
<p>This function is async-signal safe. But make sure there are no other threads running that might open file descriptors! </p>

</div>
</div>
<a class="anchor" id="a1d0a66b0e207c46dc6124ff3b2f331e6"></a><!-- doxytag: member="Passenger::getHostName" ref="a1d0a66b0e207c46dc6124ff3b2f331e6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string Passenger::getHostName </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the system's host name. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classPassenger_1_1SystemException.html" title="Represents an error returned by a system call or a standard library call.">SystemException</a></em>&nbsp;</td><td>The host name cannot be retrieved. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ade80218e8b836b796f8b960b6225b439"></a><!-- doxytag: member="Passenger::getProcessUsername" ref="ade80218e8b836b796f8b960b6225b439" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string Passenger::getProcessUsername </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the username of the user that the current process is running as. </p>
<p>If the user has no associated username, then "UID xxxx" is returned, where xxxx is the current UID. </p>

</div>
</div>
<a class="anchor" id="a448f25263af0b37b91caee3d294ec4aa"></a><!-- doxytag: member="Passenger::makeDirTree" ref="a448f25263af0b37b91caee3d294ec4aa" args="(const string &amp;path, const StaticString &amp;mode=&quot;u=rwx,g=,o=&quot;, uid_t owner=USER_NOT_GIVEN, gid_t group=GROUP_NOT_GIVEN)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Passenger::makeDirTree </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StaticString &amp;&nbsp;</td>
          <td class="paramname"> <em>mode</em> = <code>&quot;u=rwx,g=,o=&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uid_t&nbsp;</td>
          <td class="paramname"> <em>owner</em> = <code>USER_NOT_GIVEN</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gid_t&nbsp;</td>
          <td class="paramname"> <em>group</em> = <code>GROUP_NOT_GIVEN</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create the directory at the given path, creating intermediate directories if necessary. </p>
<p>The created directories' permissions are exactly as specified by the 'mode' parameter (i.e. the umask will be ignored). You can specify this directory's owner and group through the 'owner' and 'group' parameters. A value of USER_NOT_GIVEN for 'owner' and/or GROUP_NOT_GIVEN 'group' means that the owner/group should not be changed.</p>
<p>If 'path' already exists, then nothing will happen.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td>A mode string, as supported by <a class="el" href="namespacePassenger.html#ada53f5a9bdcf3d22d4a710e7ea3678e9" title="Converts a mode string into a mode_t value.">parseModeString()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classPassenger_1_1FileSystemException.html" title="A filesystem error, as returned by the operating system.">FileSystemException</a></em>&nbsp;</td><td>Something went wrong. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>InvalidModeStringException</em>&nbsp;</td><td>The mode string cannot be parsed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ada53f5a9bdcf3d22d4a710e7ea3678e9"></a><!-- doxytag: member="Passenger::parseModeString" ref="ada53f5a9bdcf3d22d4a710e7ea3678e9" args="(const StaticString &amp;mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mode_t Passenger::parseModeString </td>
          <td>(</td>
          <td class="paramtype">const StaticString &amp;&nbsp;</td>
          <td class="paramname"> <em>mode</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts a mode string into a mode_t value. </p>
<p>At this time only the symbolic mode strings are supported, e.g. something like looks this: "u=rwx,g=w,o=rx". The grammar is as follows: </p>
<div class="fragment"><pre class="fragment">   mode   ::= (clause (<span class="stringliteral">&quot;,&quot;</span> clause)*)?
   clause ::= who <span class="stringliteral">&quot;=&quot;</span> permission*
   who    ::= <span class="stringliteral">&quot;u&quot;</span> | <span class="stringliteral">&quot;g&quot;</span> | <span class="stringliteral">&quot;o&quot;</span>
   permission ::= <span class="stringliteral">&quot;r&quot;</span> | <span class="stringliteral">&quot;w&quot;</span> | <span class="stringliteral">&quot;x&quot;</span> | <span class="stringliteral">&quot;s&quot;</span>
</pre></div><p>Notes:</p>
<ul>
<li>The mode value starts with 0. So if you specify "u=rwx", then the group and world permissions will be empty (set to 0).</li>
<li>The "s" permission is only allowed for who == "u" or who == "g".</li>
<li>The return value does not depend on the umask.</li>
</ul>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InvalidModeStringException</em>&nbsp;</td><td>The mode string cannot be parsed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a35b11c8ce90e90d01380f182d82f8cac"></a><!-- doxytag: member="Passenger::passenger_bucket_create" ref="a35b11c8ce90e90d01380f182d82f8cac" args="(SessionPtr session, PassengerBucketStatePtr state, apr_bucket_alloc_t *list)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">apr_bucket * Passenger::passenger_bucket_create </td>
          <td>(</td>
          <td class="paramtype">SessionPtr&nbsp;</td>
          <td class="paramname"> <em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PassengerBucketStatePtr&nbsp;</td>
          <td class="paramname"> <em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_bucket_alloc_t *&nbsp;</td>
          <td class="paramname"> <em>list</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>We used to use an apr_bucket_pipe for forwarding the backend process's response to the HTTP client. </p>
<p>However, apr_bucket_pipe has a number of issues:</p>
<ul>
<li>It closes the pipe's file descriptor when it has reached end-of-stream, but not when an error has occurred. This behavior is undesirable because it can easily cause file descriptor leaks.</li>
<li>It does weird non-blocking-I/O related things which can cause it to read less data than can actually be read.</li>
</ul>
<p>PassengerBucket is like apr_bucket_pipe, but:</p>
<ul>
<li>It also holds a reference to a <a class="el" href="classPassenger_1_1Session.html" title="Represents a single request/response pair of an application process.">Session</a>. When a read error has occured or when end-of-stream has been reached, the <a class="el" href="classPassenger_1_1Session.html" title="Represents a single request/response pair of an application process.">Session</a> will be dereferenced, so that the underlying file descriptor is closed.</li>
<li>It ignores the APR_NONBLOCK_READ flag because that's known to cause strange I/O problems.</li>
<li>It can store its current state in a PassengerBucketState data structure. </li>
</ul>

</div>
</div>
<a class="anchor" id="a8422d210cbd2f62d21254415b5a7f747"></a><!-- doxytag: member="Passenger::removeDirTree" ref="a8422d210cbd2f62d21254415b5a7f747" args="(const string &amp;path)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Passenger::removeDirTree </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&nbsp;</td>
          <td class="paramname"> <em>path</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove an entire directory tree recursively. </p>
<p>If the directory doesn't exist then this function does nothing.</p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classPassenger_1_1FileSystemException.html" title="A filesystem error, as returned by the operating system.">FileSystemException</a></em>&nbsp;</td><td>Something went wrong. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2029ad8cb57611ab161b20ef9df39c86"></a><!-- doxytag: member="Passenger::resetSignalHandlersAndMask" ref="a2029ad8cb57611ab161b20ef9df39c86" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Passenger::resetSignalHandlersAndMask </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Resets the current process's signal handler disposition and signal mask to default values. </p>
<p>One should call this every time one forks a child process; non-default signal masks/handler dispositions can cause all kinds of weird quirks, like waitpid() malfunctioning on OS X.</p>
<p>This function is async-signal safe. </p>

</div>
</div>
<a class="anchor" id="ad233ce971fa0e937182c637bf2d1f105"></a><!-- doxytag: member="Passenger::runAndPrintExceptions" ref="ad233ce971fa0e937182c637bf2d1f105" args="(const function&lt; void()&gt; &amp;func, bool toAbort)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Passenger::runAndPrintExceptions </td>
          <td>(</td>
          <td class="paramtype">const function&lt; void()&gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>toAbort</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Runs the given function and catches any tracable_exceptions. </p>
<p>Upon catching such an exception, its message and backtrace will be printed. If toAbort is true then it will call abort(), otherwise the exception is swallowed. thread_interrupted and all other exceptions are silently propagated. </p>

</div>
</div>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
</body>
</html>
